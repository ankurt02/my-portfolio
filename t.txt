CustomInfoCard(
                    imagePath: 'assets/images/yuta01.jpeg',
                    title: 'Anime',
                    description: 'My top watched anime and thoughts.',
                    onTap: () {
                      Navigator.pushNamed(context, '/animeScreen');
                    },
                  ),
                  CustomInfoCard(
                    imagePath: 'assets/images/movie.jpeg',
                    title: 'Movies',
                    description: 'Movies that inspired me or made me think.',
                    onTap: () {
                      Navigator.pushNamed(context, '/moviesScreen');
                    },
                  ),
                  CustomInfoCard(
                    imagePath: 'assets/images/music.jpeg',
                    title: 'Music',
                    description: 'A playlist of soundtracks and songs I love.',
                    onTap: () {
                      Navigator.pushNamed(context, '/musicScreen');
                    },
                  ),
                  CustomInfoCard(
                    imagePath: 'assets/images/research.jpg',
                    title: 'Research Papers',
                    description: 'My academic interests and paper summaries.',
                    onTap: () {
                      Navigator.pushNamed(context, '/researchScreen');
                    },
                  ),





                  import 'dart:math' as math;
import 'package:flutter/material.dart';

void main() {
  runApp(const MaterialApp(
    home: AntigravityJellyfishPage(),
    debugShowCheckedModeBanner: false,
  ));
}

class AntigravityJellyfishPage extends StatelessWidget {
  const AntigravityJellyfishPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: Stack(
        children: [
          // 1. The Jellyfish/Streak Layer
          const Positioned.fill(
            child: JellyfishField(),
          ),
          
          // 2. Foreground Content
          Center(
            child: PointerInterceptor(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.change_history, size: 28, color: Colors.grey[800]),
                      const SizedBox(width: 8),
                      Text(
                        "Google Antigravity",
                        style: TextStyle(
                          color: Colors.grey[800],
                          fontSize: 20,
                          fontWeight: FontWeight.w500,
                          letterSpacing: -0.5,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 30),
                  const Text(
                    "Experience liftoff",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Colors.black,
                      fontSize: 64,
                      fontWeight: FontWeight.bold,
                      height: 1.0,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const Text(
                    "with the next-generation IDE",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Color(0xFF444444),
                      fontSize: 64,
                      fontWeight: FontWeight.w300, 
                      height: 1.1,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const SizedBox(height: 40),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 18),
                    decoration: BoxDecoration(
                      color: Colors.black,
                      borderRadius: BorderRadius.circular(50),
                    ),
                    child: const Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(Icons.window, color: Colors.white, size: 22),
                        SizedBox(width: 12),
                        Text(
                          "Download for Windows",
                          style: TextStyle(
                            color: Colors.white, 
                            fontSize: 16,
                            fontWeight: FontWeight.w600
                          ),
                        ),
                      ],
                    ),
                  )
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class PointerInterceptor extends StatelessWidget {
  final Widget child;
  const PointerInterceptor({super.key, required this.child});
  @override
  Widget build(BuildContext context) {
    return IgnorePointer(child: child);
  }
}

class JellyfishField extends StatefulWidget {
  const JellyfishField({super.key});

  @override
  State<JellyfishField> createState() => _JellyfishFieldState();
}

class _JellyfishFieldState extends State<JellyfishField>
    with SingleTickerProviderStateMixin {
  List<Offset> _dots = [];
  
  // FLUIDITY UPGRADE: Separate Target (Real Mouse) from Current (Visual)
  Offset _targetMousePos = const Offset(-1000, -1000); 
  Offset _currentMousePos = const Offset(-1000, -1000); 
  
  late AnimationController _controller;
  Size? _lastSize;

  final double _gridSpacing = 40.0; 
  final double _jitterAmount = 18.0; 

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this, 
      duration: const Duration(seconds: 6) 
    )..repeat();
    
    // Add a listener to handle the smooth interpolation every frame
    _controller.addListener(_updateMousePhysics);
  }

  void _updateMousePhysics() {
    // Fluid Drag: Move visual mouse position towards real mouse position
    if (_currentMousePos != _targetMousePos) {
       double dist = (_currentMousePos - _targetMousePos).distance;
       if (dist > 0.5) {
         setState(() {
           _currentMousePos = Offset.lerp(_currentMousePos, _targetMousePos, 0.1)!;
         });
       } else {
         _currentMousePos = _targetMousePos;
       }
    }
  }

  @override
  void dispose() {
    _controller.removeListener(_updateMousePhysics);
    _controller.dispose();
    super.dispose();
  }

  void _initDots(Size size) {
    if (_dots.isNotEmpty && _lastSize == size) return;
    _lastSize = size;
    _dots.clear();

    final random = math.Random(42); 

    int cols = (size.width / _gridSpacing).ceil() + 2;
    int rows = (size.height / _gridSpacing).ceil() + 2;

    for (int i = -1; i < cols; i++) {
      for (int j = -1; j < rows; j++) {
        double x = i * _gridSpacing;
        double y = j * _gridSpacing;

        x += (random.nextDouble() - 0.5) * 2 * _jitterAmount;
        y += (random.nextDouble() - 0.5) * 2 * _jitterAmount;

        _dots.add(Offset(x, y));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        _initDots(Size(constraints.maxWidth, constraints.maxHeight));

        return MouseRegion(
          onHover: (event) {
            _targetMousePos = event.localPosition;
          },
          onExit: (event) {
             // Optional: drift away
          },
          child: AnimatedBuilder(
            animation: _controller,
            builder: (context, child) {
              return CustomPaint(
                painter: JellyfishPainter(
                  points: _dots, 
                  mousePos: _currentMousePos, 
                  animationValue: _controller.value
                ),
                size: Size.infinite,
              );
            },
          ),
        );
      },
    );
  }
}

class JellyfishPainter extends CustomPainter {
  final List<Offset> points;
  final Offset mousePos;
  final double animationValue;

  JellyfishPainter({
    required this.points, 
    required this.mousePos, 
    required this.animationValue
  });

  final double peakRadius = 220.0;   
  final double outerRadius = 500.0;  

  final double baseLength = 6.0;     
  final double baseWidth = 3.0;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFF4285F4)
      ..strokeCap = StrokeCap.round;

    final double time = animationValue * 2 * math.pi;
    
    for (var origin in points) {
      // --- 1. AMPLIFIED FLUID MOTION ---
      // Increased multipliers for more idle movement
      
      double w1 = math.sin(time * 0.5 + (origin.dx * 0.01));
      double w2 = math.cos(time * 0.8 + (origin.dy * 0.015));
      
      // Multiplier increased from 6.0 to 14.0 for bigger wandering
      double floatX = (w1 + w2) * 14.0; 
      double floatY = (math.cos(time * 0.5 + origin.dy * 0.01) + math.sin(time + origin.dx * 0.01)) * 14.0;
      
      Offset currentPos = origin + Offset(floatX, floatY);

      // --- 2. PUMP / HEARTBEAT EFFECT ---
      // Calculate a pulsing value between -1 and 1
      double pulse = math.sin(time * 2.0 + (origin.dx * 0.02) + (origin.dy * 0.02));
      
      // Make the length change drastic:
      // Goes from 0.4x length to 1.8x length
      double lenMult = 1.1 + (pulse * 0.7); 

      // --- 3. DISTANCE CHECK ---
      double dx = currentPos.dx - mousePos.dx;
      double dy = currentPos.dy - mousePos.dy;
      double dist = math.sqrt(dx * dx + dy * dy);

      if (dist > outerRadius) continue;

      // --- 4. DIMINISHING & CALCULATIONS ---
      double scaleFactor = 0.0;

      if (dist < peakRadius) {
        scaleFactor = dist / peakRadius; 
        scaleFactor = math.pow(scaleFactor, 1.5).toDouble();
      } else {
        scaleFactor = 1.0 - ((dist - peakRadius) / (outerRadius - peakRadius));
      }

      double actualLen = baseLength * lenMult * scaleFactor;
      double actualWidth = baseWidth * scaleFactor; 

      if (actualWidth < 0.5 || actualLen < 0.5) continue;

      paint.strokeWidth = actualWidth;

      // --- 5. JELLYFISH WOBBLE (ROTATION) ---
      // Instead of pointing perfectly straight, add a rotational vibration
      double baseAngle = math.atan2(dy, dx);
      
      // Create a "wobble" offset angle.
      // Using time * 3.0 for faster vibration than the movement.
      // 0.35 radians is approx 20 degrees of wiggle.
      double wobble = math.sin(time * 3.0 + (origin.dy * 0.05)) * 0.35;
      
      double finalAngle = baseAngle + wobble;

      double cosA = math.cos(finalAngle);
      double sinA = math.sin(finalAngle);

      // --- 6. DRAW ---
      Offset start = Offset(
        currentPos.dx - (cosA * actualLen * 0.5),
        currentPos.dy - (sinA * actualLen * 0.5),
      );
      Offset end = Offset(
        currentPos.dx + (cosA * actualLen * 0.5),
        currentPos.dy + (sinA * actualLen * 0.5),
      );

      paint.color = const Color(0xFF4285F4).withOpacity((scaleFactor * 0.9).clamp(0.0, 1.0));
      
      canvas.drawLine(start, end, paint);
    }
  }

  @override
  bool shouldRepaint(covariant JellyfishPainter oldDelegate) {
    return oldDelegate.animationValue != animationValue ||
           oldDelegate.mousePos != mousePos;
  }
}




// favoured one below 
import 'dart:math' as math;
import 'package:flutter/material.dart';

void main() {
  runApp(const MaterialApp(
    home: AntigravityJellyfishPage(),
    debugShowCheckedModeBanner: false,
  ));
}

class AntigravityJellyfishPage extends StatelessWidget {
  const AntigravityJellyfishPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: Stack(
        children: [
          // 1. The Jellyfish/Streak Layer
          const Positioned.fill(
            child: JellyfishField(),
          ),
          
          // 2. Foreground Content
          Center(
            child: PointerInterceptor(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.change_history, size: 28, color: Colors.grey[800]),
                      const SizedBox(width: 8),
                      Text(
                        "Google Antigravity",
                        style: TextStyle(
                          color: Colors.grey[800],
                          fontSize: 20,
                          fontWeight: FontWeight.w500,
                          letterSpacing: -0.5,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 30),
                  const Text(
                    "Experience liftoff",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Colors.black,
                      fontSize: 64,
                      fontWeight: FontWeight.bold,
                      height: 1.0,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const Text(
                    "with the next-generation IDE",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Color(0xFF444444),
                      fontSize: 64,
                      fontWeight: FontWeight.w300, 
                      height: 1.1,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const SizedBox(height: 40),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 18),
                    decoration: BoxDecoration(
                      color: Colors.black,
                      borderRadius: BorderRadius.circular(50),
                    ),
                    child: const Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(Icons.window, color: Colors.white, size: 22),
                        SizedBox(width: 12),
                        Text(
                          "Download for Windows",
                          style: TextStyle(
                            color: Colors.white, 
                            fontSize: 16,
                            fontWeight: FontWeight.w600
                          ),
                        ),
                      ],
                    ),
                  )
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class PointerInterceptor extends StatelessWidget {
  final Widget child;
  const PointerInterceptor({super.key, required this.child});
  @override
  Widget build(BuildContext context) {
    return IgnorePointer(child: child);
  }
}

class JellyfishField extends StatefulWidget {
  const JellyfishField({super.key});

  @override
  State<JellyfishField> createState() => _JellyfishFieldState();
}

class _JellyfishFieldState extends State<JellyfishField>
    with SingleTickerProviderStateMixin {
  List<Offset> _dots = [];
  
  // FLUIDITY UPGRADE: Separate Target (Real Mouse) from Current (Visual)
  Offset _targetMousePos = const Offset(-1000, -1000); 
  Offset _currentMousePos = const Offset(-1000, -1000); 
  
  late AnimationController _controller;
  Size? _lastSize;

  final double _gridSpacing = 40.0; 
  final double _jitterAmount = 18.0; 

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this, 
      duration: const Duration(seconds: 6) 
    )..repeat();
    
    // Add a listener to handle the smooth interpolation every frame
    _controller.addListener(_updateMousePhysics);
  }

  void _updateMousePhysics() {
    // This creates the "Fluid Drag" effect.
    // Instead of snapping instantly, the field position moves 10% closer
    // to the real mouse position every frame.
    if (_currentMousePos != _targetMousePos) {
       // Check distance to avoid infinite tiny calculations
       double dist = (_currentMousePos - _targetMousePos).distance;
       if (dist > 0.5) {
         setState(() {
           _currentMousePos = Offset.lerp(_currentMousePos, _targetMousePos, 0.1)!;
         });
       } else {
         _currentMousePos = _targetMousePos;
       }
    }
  }

  @override
  void dispose() {
    _controller.removeListener(_updateMousePhysics);
    _controller.dispose();
    super.dispose();
  }

  void _initDots(Size size) {
    if (_dots.isNotEmpty && _lastSize == size) return;
    _lastSize = size;
    _dots.clear();

    final random = math.Random(42); 

    int cols = (size.width / _gridSpacing).ceil() + 2;
    int rows = (size.height / _gridSpacing).ceil() + 2;

    for (int i = -1; i < cols; i++) {
      for (int j = -1; j < rows; j++) {
        double x = i * _gridSpacing;
        double y = j * _gridSpacing;

        x += (random.nextDouble() - 0.5) * 2 * _jitterAmount;
        y += (random.nextDouble() - 0.5) * 2 * _jitterAmount;

        _dots.add(Offset(x, y));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        _initDots(Size(constraints.maxWidth, constraints.maxHeight));

        return MouseRegion(
          onHover: (event) {
            // Update target, let the physics loop handle the smoothing
            _targetMousePos = event.localPosition;
          },
          onExit: (event) {
             // Optional: drift away
          },
          child: AnimatedBuilder(
            animation: _controller,
            builder: (context, child) {
              return CustomPaint(
                // Pass the SMOOTHED position, not the raw one
                painter: JellyfishPainter(
                  points: _dots, 
                  mousePos: _currentMousePos, 
                  animationValue: _controller.value
                ),
                size: Size.infinite,
              );
            },
          ),
        );
      },
    );
  }
}

class JellyfishPainter extends CustomPainter {
  final List<Offset> points;
  final Offset mousePos;
  final double animationValue;

  JellyfishPainter({
    required this.points, 
    required this.mousePos, 
    required this.animationValue
  });

  final double peakRadius = 220.0;   
  final double outerRadius = 500.0;  

  final double baseLength = 6.0;     
  final double baseWidth = 3.0;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFF4285F4)
      ..strokeCap = StrokeCap.round;

    final double time = animationValue * 2 * math.pi;
    
    for (var origin in points) {
      // --- 1. FLUID MOTION (Compound Waves) ---
      // We combine two sine waves at different frequencies.
      // This breaks the "circular" look and makes it look like water currents.
      
      // Wave 1: Slow, large movement
      double w1 = math.sin(time * 0.5 + (origin.dx * 0.01));
      // Wave 2: Faster, perpendicular ripple
      double w2 = math.cos(time * 0.8 + (origin.dy * 0.015));
      
      // Combined drift
      double floatX = (w1 + w2) * 6.0; 
      double floatY = (math.cos(time * 0.5 + origin.dy * 0.01) + math.sin(time + origin.dx * 0.01)) * 6.0;
      
      Offset currentPos = origin + Offset(floatX, floatY);

      // --- 2. DYNAMIC PULSE ---
      // Dots breathe based on the composite wave too
      double pulse = math.sin(time + (origin.dx * 0.02) + (origin.dy * 0.02));
      double lenMult = 1.0 + (pulse * 0.25); 

      // --- 3. DISTANCE & VISIBILITY ---
      double dx = currentPos.dx - mousePos.dx;
      double dy = currentPos.dy - mousePos.dy;
      double dist = math.sqrt(dx * dx + dy * dy);

      if (dist > outerRadius) continue;

      // --- 4. DIMINISHING LOGIC ---
      double scaleFactor = 0.0;

      if (dist < peakRadius) {
        scaleFactor = dist / peakRadius; 
        scaleFactor = math.pow(scaleFactor, 1.5).toDouble();
      } else {
        scaleFactor = 1.0 - ((dist - peakRadius) / (outerRadius - peakRadius));
      }

      double actualLen = baseLength * lenMult * scaleFactor;
      double actualWidth = baseWidth * scaleFactor; 

      if (actualWidth < 0.5 || actualLen < 0.5) continue;

      paint.strokeWidth = actualWidth;

      // --- 5. DRAW ---
      double angle = math.atan2(dy, dx);
      double cosA = math.cos(angle);
      double sinA = math.sin(angle);

      Offset start = Offset(
        currentPos.dx - (cosA * actualLen * 0.5),
        currentPos.dy - (sinA * actualLen * 0.5),
      );
      Offset end = Offset(
        currentPos.dx + (cosA * actualLen * 0.5),
        currentPos.dy + (sinA * actualLen * 0.5),
      );

      paint.color = const Color(0xFF4285F4).withOpacity((scaleFactor * 0.9).clamp(0.0, 1.0));
      
      canvas.drawLine(start, end, paint);
    }
  }

  @override
  bool shouldRepaint(covariant JellyfishPainter oldDelegate) {
    return oldDelegate.animationValue != animationValue ||
           oldDelegate.mousePos != mousePos;
  }
}




/// SECOND favoured
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart'; // Needed for smooth infinite animation

void main() {
  runApp(const MaterialApp(
    home: AntigravityJellyfishPage(),
    debugShowCheckedModeBanner: false,
  ));
}

class AntigravityJellyfishPage extends StatelessWidget {
  const AntigravityJellyfishPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: Stack(
        children: [
          // 1. The Jellyfish/Streak Layer
          const Positioned.fill(
            child: JellyfishField(),
          ),
          
          // 2. Foreground Content
          Center(
            child: PointerInterceptor(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.change_history, size: 28, color: Colors.grey[800]),
                      const SizedBox(width: 8),
                      Text(
                        "Google Antigravity",
                        style: TextStyle(
                          color: Colors.grey[800],
                          fontSize: 20,
                          fontWeight: FontWeight.w500,
                          letterSpacing: -0.5,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 30),
                  const Text(
                    "Experience liftoff",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Colors.black,
                      fontSize: 64,
                      fontWeight: FontWeight.bold,
                      height: 1.0,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const Text(
                    "with the next-generation IDE",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Color(0xFF444444),
                      fontSize: 64,
                      fontWeight: FontWeight.w300, 
                      height: 1.1,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const SizedBox(height: 40),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 18),
                    decoration: BoxDecoration(
                      color: Colors.black,
                      borderRadius: BorderRadius.circular(50),
                    ),
                    child: const Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(Icons.window, color: Colors.white, size: 22),
                        SizedBox(width: 12),
                        Text(
                          "Download for Windows",
                          style: TextStyle(
                            color: Colors.white, 
                            fontSize: 16,
                            fontWeight: FontWeight.w600
                          ),
                        ),
                      ],
                    ),
                  )
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class PointerInterceptor extends StatelessWidget {
  final Widget child;
  const PointerInterceptor({super.key, required this.child});
  @override
  Widget build(BuildContext context) {
    return IgnorePointer(child: child);
  }
}

class JellyfishField extends StatefulWidget {
  const JellyfishField({super.key});

  @override
  State<JellyfishField> createState() => _JellyfishFieldState();
}

class _JellyfishFieldState extends State<JellyfishField>
    with SingleTickerProviderStateMixin {
  List<Offset> _dots = [];
  
  // PHYSICS STATE
  Offset _targetMousePos = const Offset(-1000, -1000); 
  Offset _currentMousePos = const Offset(-1000, -1000); 
  
  late Ticker _ticker;
  double _time = 0.0;
  
  Size? _lastSize;

  // INCREASED DENSITY: Reduced spacing from 45.0 to 24.0 to get more dots at border
  final double _gridSpacing = 36.0; 
  final double _jitterAmount = 11.0; // Slightly reduced jitter to prevent overlap with tighter grid

  @override
  void initState() {
    super.initState();
    _ticker = createTicker((elapsed) {
      setState(() {
        _time = elapsed.inMilliseconds / 1000.0;

        if (_currentMousePos != _targetMousePos) {
           double dist = (_currentMousePos - _targetMousePos).distance;
           if (dist > 0.5) {
             _currentMousePos = Offset.lerp(_currentMousePos, _targetMousePos, 0.15)!;
           } else {
             _currentMousePos = _targetMousePos;
           }
        }
      });
    });
    _ticker.start();
  }

  @override
  void dispose() {
    _ticker.dispose();
    super.dispose();
  }

  void _initDots(Size size) {
    if (_dots.isNotEmpty && _lastSize == size) return;
    _lastSize = size;
    _dots.clear();

    final random = math.Random(52); 

    int cols = (size.width / _gridSpacing).ceil() + 2;
    int rows = (size.height / _gridSpacing).ceil() + 2;

    for (int i = -1; i < cols; i++) {
      for (int j = -1; j < rows; j++) {
        double x = i * _gridSpacing;
        double y = j * _gridSpacing;

        x += (random.nextDouble() - 0.5) * 2 * _jitterAmount;
        y += (random.nextDouble() - 0.5) * 2 * _jitterAmount;

        _dots.add(Offset(x, y));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        _initDots(Size(constraints.maxWidth, constraints.maxHeight));

        return MouseRegion(
          onHover: (event) {
            _targetMousePos = event.localPosition;
          },
          onExit: (event) {
             // Optional: drift away
          },
          child: CustomPaint(
            painter: JellyfishPainter(
              points: _dots, 
              mousePos: _currentMousePos, 
              time: _time
            ),
            size: Size.infinite,
          ),
        );
      },
    );
  }
}

class JellyfishPainter extends CustomPainter {
  final List<Offset> points;
  final Offset mousePos;
  final double time;

  JellyfishPainter({
    required this.points, 
    required this.mousePos, 
    required this.time
  });

  // ZONES
  final double centerZoneRadius = 120.0 * 0.65; 
  final double peakRadius = 260.0 * 0.65;       
  // Lowered contraction start to widen the active border zone
  final double contractionRadius = 340.0 * 0.65; 
  final double outerRadius = 500.0 * 0.65;       

  final double baseLength = 5.0;     
  final double baseWidth = 4.0;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFF4285F4)
      ..strokeCap = StrokeCap.round;

    for (var origin in points) {
      // --- 1. FLUID MOTION ---
      double w1 = math.sin(time * 0.5 + (origin.dx * 0.01));
      double w2 = math.cos(time * 0.8 + (origin.dy * 0.015));
      
      double floatX = (w1 + w2) * 14.0; 
      double floatY = (math.cos(time * 0.5 + origin.dy * 0.01) + math.sin(time + origin.dx * 0.01)) * 14.0;
      
      Offset currentPos = origin + Offset(floatX, floatY);

      // --- DISTANCE CHECK ---
      double dx = currentPos.dx - mousePos.dx;
      double dy = currentPos.dy - mousePos.dy;
      double dist = math.sqrt(dx * dx + dy * dy);

      if (dist > outerRadius) continue;

      // --- 2. CENTER ZONE (SPARSITY LOGIC) ---
      if (dist < centerZoneRadius) {
        int hash = (origin.dx.toInt() ^ origin.dy.toInt());
        if ((hash % 10) > 2) {
           continue; 
        }
      }

      // --- 3. OUTER CONTRACTION (Increased Movement) ---
      if (dist > contractionRadius) {
        double angleToMouse = math.atan2(dy, dx);
        double outwardFactor = (dist - contractionRadius) / (outerRadius - contractionRadius);
        
        // Add sine wave for rhythmic "swimming" contraction
        double swimCycle = math.sin(time * 2.0 + (origin.dy * 0.05));
        
        // Increased pullAmount to 220.0 for VERY strong inward movement
        double pullAmount = 220.0 * outwardFactor * swimCycle; 
        
        // Important: Subtract to pull inward
        currentPos -= Offset(
          math.cos(angleToMouse) * pullAmount,
          math.sin(angleToMouse) * pullAmount
        );
      }

      // --- 4. DYNAMIC PULSE SPEED ---
      double speedBlend = (dist / outerRadius).clamp(0.0, 1.0);
      double phase = (origin.dx * 0.02) + (origin.dy * 0.02);
      double combinedPulse = (math.sin(time * 1.5 + phase) * (1.0 - speedBlend)) + 
                             (math.sin(time * 6.0 + phase) * speedBlend);
      double lenMult = 1.3 + (combinedPulse * 0.5); 

      // --- 5. DIMINISHING & SHAPE LOGIC ---
      double scaleFactor = 1.0;
      double actualLen = baseLength;

      if (dist < centerZoneRadius) {
        // ZONE 1: CENTER
        actualLen = 0.1; 
        scaleFactor = 0.6; 
        
      } else if (dist < peakRadius) {
        // ZONE 2: TRANSITION
        double t = (dist - centerZoneRadius) / (peakRadius - centerZoneRadius);
        t = t * t * (3 - 2 * t); 
        
        actualLen = 0.1 + (baseLength * lenMult * t);
        scaleFactor = 0.6 + (0.4 * t); 
        
      } else if (dist > contractionRadius) {
        // ZONE 3: OUTER FADE
        scaleFactor = 1.0 - ((dist - contractionRadius) / (outerRadius - contractionRadius));
        actualLen = baseLength * lenMult * scaleFactor;
      } else {
        // ZONE 4: PLATEAU
        actualLen = baseLength * lenMult;
      }

      double actualWidth = baseWidth * scaleFactor; 

      if (actualWidth < 0.5) continue;

      paint.strokeWidth = actualWidth;

      // --- 6. ROTATION (WOBBLE) ---
      double baseAngle = math.atan2(dy, dx);
      double wobble = math.sin(time * 3.0 + (origin.dy * 0.05)) * 0.12;
      double finalAngle = baseAngle + wobble;

      double cosA = math.cos(finalAngle);
      double sinA = math.sin(finalAngle);

      // --- 7. DRAW ---
      Offset start = Offset(
        currentPos.dx - (cosA * actualLen * 0.5),
        currentPos.dy - (sinA * actualLen * 0.5),
      );
      Offset end = Offset(
        currentPos.dx + (cosA * actualLen * 0.5),
        currentPos.dy + (sinA * actualLen * 0.5),
      );

      paint.color = const Color(0xFF4285F4).withOpacity((scaleFactor * 0.9).clamp(0.0, 1.0));
      
      canvas.drawLine(start, end, paint);
    }
  }

  @override
  bool shouldRepaint(covariant JellyfishPainter oldDelegate) {
    return oldDelegate.time != time ||
           oldDelegate.mousePos != mousePos;
  }
}




// THIRD
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart'; // Needed for smooth infinite animation

void main() {
  runApp(const MaterialApp(
    home: AntigravityJellyfishPage(),
    debugShowCheckedModeBanner: false,
  ));
}

class AntigravityJellyfishPage extends StatelessWidget {
  const AntigravityJellyfishPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: Stack(
        children: [
          // 1. The Jellyfish/Streak Layer
          const Positioned.fill(
            child: JellyfishField(),
          ),
          
          // 2. Foreground Content
          Center(
            child: PointerInterceptor(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.change_history, size: 28, color: Colors.grey[800]),
                      const SizedBox(width: 8),
                      Text(
                        "Google Antigravity",
                        style: TextStyle(
                          color: Colors.grey[800],
                          fontSize: 20,
                          fontWeight: FontWeight.w500,
                          letterSpacing: -0.5,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 30),
                  const Text(
                    "Experience liftoff",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Colors.black,
                      fontSize: 64,
                      fontWeight: FontWeight.bold,
                      height: 1.0,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const Text(
                    "with the next-generation IDE",
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: Color(0xFF444444),
                      fontSize: 64,
                      fontWeight: FontWeight.w300, 
                      height: 1.1,
                      letterSpacing: -2.0,
                    ),
                  ),
                  const SizedBox(height: 40),
                  Container(
                    padding: const EdgeInsets.symmetric(horizontal: 28, vertical: 18),
                    decoration: BoxDecoration(
                      color: Colors.black,
                      borderRadius: BorderRadius.circular(50),
                    ),
                    child: const Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(Icons.window, color: Colors.white, size: 22),
                        SizedBox(width: 12),
                        Text(
                          "Download for Windows",
                          style: TextStyle(
                            color: Colors.white, 
                            fontSize: 16,
                            fontWeight: FontWeight.w600
                          ),
                        ),
                      ],
                    ),
                  )
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class PointerInterceptor extends StatelessWidget {
  final Widget child;
  const PointerInterceptor({super.key, required this.child});
  @override
  Widget build(BuildContext context) {
    return IgnorePointer(child: child);
  }
}

class JellyfishField extends StatefulWidget {
  const JellyfishField({super.key});

  @override
  State<JellyfishField> createState() => _JellyfishFieldState();
}

class _JellyfishFieldState extends State<JellyfishField>
    with SingleTickerProviderStateMixin {
  List<Offset> _dots = [];
  
  // PHYSICS STATE
  Offset _targetMousePos = const Offset(-1000, -1000); 
  Offset _currentMousePos = const Offset(-1000, -1000); 
  
  late Ticker _ticker;
  double _time = 0.0;
  
  Size? _lastSize;

  // INCREASED DENSITY: Reduced spacing from 45.0 to 24.0 to get more dots at border
  final double _gridSpacing = 36.0; 
  final double _jitterAmount = 12.0; // Slightly reduced jitter to prevent overlap with tighter grid

  @override
  void initState() {
    super.initState();
    _ticker = createTicker((elapsed) {
      setState(() {
        _time = elapsed.inMilliseconds / 1000.0;

        if (_currentMousePos != _targetMousePos) {
           double dist = (_currentMousePos - _targetMousePos).distance;
           if (dist > 0.5) {
             _currentMousePos = Offset.lerp(_currentMousePos, _targetMousePos, 0.15)!;
           } else {
             _currentMousePos = _targetMousePos;
           }
        }
      });
    });
    _ticker.start();
  }

  @override
  void dispose() {
    _ticker.dispose();
    super.dispose();
  }

  void _initDots(Size size) {
    if (_dots.isNotEmpty && _lastSize == size) return;
    _lastSize = size;
    _dots.clear();

    final random = math.Random(64); 

    int cols = (size.width / _gridSpacing).ceil() + 2;
    int rows = (size.height / _gridSpacing).ceil() + 2;

    for (int i = -1; i < cols; i++) {
      for (int j = -1; j < rows; j++) {
        double x = i * _gridSpacing;
        double y = j * _gridSpacing;

        x += (random.nextDouble() - 0.5) * 2 * _jitterAmount;
        y += (random.nextDouble() - 0.5) * 2 * _jitterAmount;

        _dots.add(Offset(x, y));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        _initDots(Size(constraints.maxWidth, constraints.maxHeight));

        return MouseRegion(
          onHover: (event) {
            _targetMousePos = event.localPosition;
          },
          onExit: (event) {
             // Optional: drift away
          },
          child: CustomPaint(
            painter: JellyfishPainter(
              points: _dots, 
              mousePos: _currentMousePos, 
              time: _time
            ),
            size: Size.infinite,
          ),
        );
      },
    );
  }
}

class JellyfishPainter extends CustomPainter {
  final List<Offset> points;
  final Offset mousePos;
  final double time;

  JellyfishPainter({
    required this.points, 
    required this.mousePos, 
    required this.time
  });

  // ZONES
  final double centerZoneRadius = 120.0 * 0.65; 
  final double peakRadius = 260.0 * 0.65;       
  // Lowered contraction start to widen the active border zone
  final double contractionRadius = 340.0 * 0.65; 
  final double outerRadius = 500.0 * 0.65;       

  final double baseLength = 5.0;     
  final double baseWidth = 3.0;

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFF4285F4)
      ..strokeCap = StrokeCap.round;

    for (var origin in points) {
      // --- 1. FLUID MOTION ---
      double w1 = math.sin(time * 0.5 + (origin.dx * 0.01));
      double w2 = math.cos(time * 0.8 + (origin.dy * 0.015));
      
      double floatX = (w1 + w2) * 14.0; 
      double floatY = (math.cos(time * 0.5 + origin.dy * 0.01) + math.sin(time + origin.dx * 0.01)) * 14.0;
      
      Offset currentPos = origin + Offset(floatX, floatY);

      // --- DISTANCE CHECK ---
      double dx = currentPos.dx - mousePos.dx;
      double dy = currentPos.dy - mousePos.dy;
      double dist = math.sqrt(dx * dx + dy * dy);

      if (dist > outerRadius) continue;

      // --- 2. CENTER ZONE (SPARSITY LOGIC) ---
      if (dist < centerZoneRadius) {
        int hash = (origin.dx.toInt() ^ origin.dy.toInt());
        if ((hash % 10) > 2) {
           continue; 
        }
      }

      // --- 3. OUTER CONTRACTION (Increased Movement) ---
      if (dist > contractionRadius) {
        double angleToMouse = math.atan2(dy, dx);
        double outwardFactor = (dist - contractionRadius) / (outerRadius - contractionRadius);
        
        // Add sine wave for rhythmic "swimming" contraction
        double swimCycle = math.sin(time * 2.0 + (origin.dy * 0.05));
        
        // Increased pullAmount to 220.0 for VERY strong inward movement
        double pullAmount = 220.0 * outwardFactor * swimCycle; 
        
        // Important: Subtract to pull inward
        currentPos -= Offset(
          math.cos(angleToMouse) * pullAmount,
          math.sin(angleToMouse) * pullAmount
        );
      }

      // --- 4. DYNAMIC PULSE SPEED ---
      double speedBlend = (dist / outerRadius).clamp(0.0, 1.0);
      double phase = (origin.dx * 0.02) + (origin.dy * 0.02);
      double combinedPulse = (math.sin(time * 1.5 + phase) * (1.0 - speedBlend)) + 
                             (math.sin(time * 6.0 + phase) * speedBlend);
      double lenMult = 1.3 + (combinedPulse * 0.5); 

      // --- 5. DIMINISHING & SHAPE LOGIC ---
      double scaleFactor = 1.0;
      double actualLen = baseLength;

      if (dist < centerZoneRadius) {
        // ZONE 1: CENTER
        actualLen = 0.1; 
        scaleFactor = 0.6; 
        
      } else if (dist < peakRadius) {
        // ZONE 2: TRANSITION
        double t = (dist - centerZoneRadius) / (peakRadius - centerZoneRadius);
        t = t * t * (3 - 2 * t); 
        
        actualLen = 0.1 + (baseLength * lenMult * t);
        scaleFactor = 0.6 + (0.4 * t); 
        
      } else if (dist > contractionRadius) {
        // ZONE 3: OUTER FADE
        scaleFactor = 1.0 - ((dist - contractionRadius) / (outerRadius - contractionRadius));
        actualLen = baseLength * lenMult * scaleFactor;
      } else {
        // ZONE 4: PLATEAU
        actualLen = baseLength * lenMult;
      }

      double actualWidth = baseWidth * scaleFactor; 

      if (actualWidth < 0.5) continue;

      paint.strokeWidth = actualWidth;

      // --- 6. ROTATION (WOBBLE) ---
      double baseAngle = math.atan2(dy, dx);
      double wobble = math.sin(time * 3.0 + (origin.dy * 0.05)) * 0.12;
      double finalAngle = baseAngle + wobble;

      double cosA = math.cos(finalAngle);
      double sinA = math.sin(finalAngle);

      // --- 7. DRAW ---
      Offset start = Offset(
        currentPos.dx - (cosA * actualLen * 0.5),
        currentPos.dy - (sinA * actualLen * 0.5),
      );
      Offset end = Offset(
        currentPos.dx + (cosA * actualLen * 0.5),
        currentPos.dy + (sinA * actualLen * 0.5),
      );

      paint.color = const Color(0xFF4285F4).withOpacity((scaleFactor * 0.9).clamp(0.0, 1.0));
      
      canvas.drawLine(start, end, paint);
    }
  }

  @override
  bool shouldRepaint(covariant JellyfishPainter oldDelegate) {
    return oldDelegate.time != time ||
           oldDelegate.mousePos != mousePos;
  }
}



// animated misc card - border gradient MOTION
import 'package:flutter/material.dart';
import 'package:gap/gap.dart';
import 'package:google_fonts/google_fonts.dart';
import 'dart:math' as math;

class CustomInfoCard extends StatefulWidget {
  final String imagePath;
  final String title;
  final String description;
  final VoidCallback? onTap;
  final List<Color> gradientColors;

  const CustomInfoCard({
    super.key,
    required this.imagePath,
    required this.title,
    required this.description,
    required this.gradientColors,
    this.onTap,
  });

  @override
  State<CustomInfoCard> createState() => _CustomInfoCardState();
}

class _CustomInfoCardState extends State<CustomInfoCard>
    with SingleTickerProviderStateMixin {
  bool _isHovered = false;
  late AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 5),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        transform: _isHovered
            ? (Matrix4.identity()
              ..translate(0, -8, 0)
              ..scale(1.05))
            : Matrix4.identity(),
        margin: const EdgeInsets.all(8),
        

        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  colors: widget.gradientColors,
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  transform: GradientRotation(_controller.value * 2 * math.pi),
                ),
                borderRadius: BorderRadius.circular(16),
              ),
              child: child,
            );
          },


          child: InkWell(
            onTap: widget.onTap,
            borderRadius: BorderRadius.circular(14),
            child: Container(
              margin: const EdgeInsets.all(2.75), // This creates the border width
              decoration: BoxDecoration(
                color: const Color(0xFF121212), // Inner background
                borderRadius: BorderRadius.circular(14),
              ),
              padding: const EdgeInsets.all(12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.center,
                mainAxisSize: MainAxisSize.min,
                children: [
                  ClipRRect(
                    borderRadius:
                        const BorderRadius.vertical(top: Radius.circular(8)),
                    child: Image.asset(
                      widget.imagePath,
                      fit: BoxFit.cover,
                      height: 240,
                      width: double.infinity,
                      errorBuilder: (context, error, stackTrace) {
                        return Container(
                          height: 240,
                          color: Colors.grey[900],
                          child: const Icon(Icons.broken_image,
                              color: Colors.white24, size: 50),
                        );
                      },
                    ),
                  ),
                  const Gap(12),
                  Text(
                    widget.title,
                    style: GoogleFonts.jetBrainsMono(
                      fontSize: 16,
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const Gap(8),
                  Text(
                    widget.description,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.jetBrainsMono(
                      fontSize: 12,
                      color: Colors.white70,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}


class GradientRotation extends GradientTransform {
  final double radians;

  const GradientRotation(this.radians);

  @override
  Matrix4 transform(Rect bounds, {TextDirection? textDirection}) {
    return Matrix4.identity()
      ..translate(bounds.center.dx, bounds.center.dy)
      ..rotateZ(radians)
      ..translate(-bounds.center.dx, -bounds.center.dy);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is GradientRotation && other.radians == radians;
  }

  @override
  int get hashCode => radians.hashCode;
}